- block:
  - set_fact:
      title: "manage image {{ lookup('vars', image).name }} -"

  - name: "{{ title }} process image"
    debug:
      msg: "image:\n{{ lookup('vars', image) | to_nice_yaml}}"
    when: "'debug' in ansible_run_tags"
      
  - name: "{{ title }} assert variables"
    vars:
      i: "{{ lookup('vars', image) }}"
    ansible.builtin.assert:
      that:
        - i.type is defined
        - i.section is defined
        - i.tag is defined
        - i.type != 'fetch'  or i.source is defined
        - i.type != 'script' or i.command is defined
        - i.type != 'script' or i.name is defined

  - set_fact:
      t: "{{ lookup('vars', image) }}"
      var_stack: "{{ (var_stack | default([])) + [image] }}"

  - debug:
      msg: "t:{{ t }}\nvar_stack:\n{{ var_stack | to_nice_yaml}}\nimage:\n{{image | to_nice_yaml }}\n"
    when: "'debug' in ansible_run_tags"

  - block:
    - name: "{{ title }} handle required base images"
      include_tasks: image.yaml
      vars:
        image: "{{ 'loop_'~t.name|replace('-', '_') }}"
      when: "{{ t.name not in images_processed }}"
      loop: "{{ images | selectattr('name', 'defined') | selectattr('name', 'in', t.requires|default([]) ) }}"
      loop_control:
        loop_var: "{{ 'loop_'~t.name|replace('-', '_') }}"
  
  - name: "recursion end - set vars to complete the upstream image"
    set_fact:
      image_var: "{{ var_stack[-1] }}"
      title: "manage image {{ lookup('vars', var_stack[-1]).name }} -"
      var_stack: "{{ var_stack[0:-1] }}"
      image_info: "{{ lookup('vars', var_stack[-1]) }}"

- name: "{{ title }} check if image exists already"
  uri:
    url: "https://{{ registry }}/v2/{{ image_info.section }}/{{ image_info.name }}/manifests/{{ image_info.tag | default('latest') }}"
    headers:
      Accept: application/vnd.oci.image.manifest.v1+json
    method: "GET"
  register: check_image
  when: "'no_exists_check' not in ansible_run_tags"
  failed_when: false

- debug:
    msg: "check_image type: {{ check_image.status | type_debug }}\n{{ check_image | to_nice_yaml }}\nimages_processed:\n{{ images_processed | to_nice_yaml }}"
  when: "'debug' in ansible_run_tags"

- block: # build something
  - block: # gentoo image builder
    - name: "{{ title }} variables - 1"
      set_fact:
        requires: "{{ image_info.requires | default(['core'])| first }}" # as scratch should be the only image without requires attribute
        dest_dir: "{{ builder.base }}/{{ image_info.section }}/{{ image_info.name }}"
        build_dir: "{{ builder.base }}/build"
        stage3_image: "{{ builder.build_dir }}/{{ builder.stage3_base }}:{{ builder.stage3_date }}"
        stage3_url: "https://distfiles.gentoo.org/releases/{{ default_platform }}/autobuilds/{{ builder.stage3_date }}/"
        stage3_file: "{{ builder.stage3_base }}-{{ builder.stage3_date }}.tar.xz"
        core_builder: "{{ builder.build_dir }}/{{ builder.default_builder }}-core:{{ builder.portage }}"
        build_image: "{{ registry }}/{{ image_info.section }}/{{ image_info.name }}:{{ image_info.tag }}"
        builder_image: "{{ image_info.section }}/{{ builder.default_builder }}-{{ image_info.name }}:{{ image_info.tag }}"
        latest_image: "{{ registry }}/{{ image_info.section }}/{{ image_info.name }}:latest"

    - name: "{{ title }} check for builder image availability"
      shell: |
        podman image inspect --format " " {{ builder_image }} 2>&1
      failed_when: false
      register: check_builder

    - name: "{{ title }} variables - 2"
      set_fact:
        req_section: "{{ images | selectattr('name', 'defined') | selectattr('name', 'equalto', requires ) | map(attribute='section') | first| default('build')}}"
        req_tag: "{{ images | selectattr('name', 'defined') | selectattr('name', 'equalto', requires ) | map(attribute='tag') |first | default(builder.portage)}}"
        portage_dir: "{{ build_dir }}/portage-{{ builder.portage }}"
    - name: "{{ title }} directories"
      file:
        path: "{{ item }}"
        recurse: true
        state: directory
      loop:
      - "{{ dest_dir }}"
      - "{{ build_dir }}"

    - block: # check only when image_info.name == 'scratch'
      # portage
      - name: "{{ title }} check for portage directory existance"
        stat:
          path: "{{ portage_dir }}"
        failed_when: false
        register: check_portage
        
      - debug:
          msg: "check_portage: {{ check_portage }}"
      - block:
        - name: "{{ title }} get portage"
          get_url:
            url: https://distfiles.gentoo.org/snapshots/portage-{{ builder.portage }}.tar.xz
            dest: "{{ build_dir }}/"
        - name: "{{ title }} extract portage archive"
          shell: |
            mkdir -p "{{ portage_dir }}" && tar --directory "{{ portage_dir }}" -xf "{{ build_dir }}/portage-{{ builder.portage }}.tar.xz" --strip-components=1
        when: not check_portage.stat.exists
        
      # stage3 
      - name: "{{ title }} check for stage3 image availability"
        shell: |
          podman image inspect --format " " {{ stage3_image }} 2>&1
        failed_when: false
        register: check_stage3
        
      - block:
        - debug:
            msg: "stage3 source: {{ stage3_url }}/{{ stage3_file }}"
        - name: "{{ title }} get stage3"
          get_url:
            url: "{{ stage3_url }}/{{ stage3_file }}"
            dest: "{{ build_dir }}/"
        - name: "{{ title }} build stage3 image"
          shell: |
            podman import "{{ build_dir }}/{{ stage3_file }}" {{ stage3_image }}
        when: "check_stage3.rc != 0 or not check_portage.stat.exists"
        
      # core builder
      - name: "{{ title }} check for core builder image availability"
        shell: |
          podman image inspect --format " " {{ core_builder }} 2>&1
        failed_when: false
        register: check_core
        
      - block:
        - name: "{{ title }} build core builder image"
          shell: |
            cat >> {{ build_dir }}/Dockerfile.core <<EOF
            FROM {{ stage3_image }}
            {{ builder.env }}
            EOF
            podman build -f {{ build_dir }}/Dockerfile.core -t {{ core_builder }} > >(tee -a {{ build_dir }}/podman-build.log) 2> >(tee -a {{ build_dir }}/podman-build.log >&2)
        when: "check_core.rc != 0 or check_stage3.rc != 0 or not check_portage.stat.exists"
        
      # scratch builder
      - name: "{{ title }} check for scratch builder image availability"
        shell: |
          podman image inspect --format " " {{ builder_image }} 2>&1
        failed_when: false
        register: check_scratch
      when: image_info.name == 'scratch'

    - name: "{{ title }} create build.sh"
      vars:
        build_sh: "{{ dest_dir }}/build.sh"
      shell: |
        echo '_packages="{{ image_info.build.packages | default('') }}"' > "{{ build_sh }}"
        set -x

        cat >> "{{ build_sh }}" <<"INLINE"
        configure_builder(){
          {{ image_info.build.configure_builder | default('true') }}
        }
        INLINE
        cat >> "{{ build_sh }}" <<"INLINE"
        configure_rootfs_build(){
          {{ image_info.build.configure_rootfs_build | default('true') }}
        }
        INLINE
        echo 'finish_rootfs_build(){
          {{ image_info.build.finish_rootfs_build | default('true') }}
        }' >> "{{ build_sh }}"
        echo 'purge_image_root(){
          {{ builder.purge_image_root | default('true') }}
        }' >> "{{ build_sh }}"

    - name: "{{ title }} create Dockerfile"
      vars:
        entrypoint: "{{ image_info.build.entrypoint }}"
        user: "{{ image_info.build.user }}"
        workdir: "{{ image_info.workdir }}"
        env: "{{ image_info.env }}"
      shell: |
        cat > "{{ dest_dir }}/Dockerfile" <<"EOF"
        FROM {{ req_section }}/{{ builder.default_builder }}-{{ requires }}:{{ req_tag }} as builder
        ADD build.sh /
        RUN source /build.sh && configure_builder && export ROOT=/image-root && configure_rootfs_build && ([ ! -z "${_packages}" ] && emerge --binpkg-respect-use=y -v ${_packages}; true ) && finish_rootfs_build && purge_image_root
        FROM {% if requires == 'scratch' %}scratch{% else %}{{ registry }}/{{ req_section }}/{{ requires }}:{{ req_tag }}{% endif %}

        {% if env is defined -%}
        {% for e in env %}
        ENV {{ e }}="{{ env[e] }}"
        {% endfor %}
        {% endif %}

        COPY --from=builder /image-root/ /
        {% if workdir is defined -%}
        WORKDIR "{{ workdir }}"
        {% endif %}
        {% if user is defined -%}
        USER "{{ user }}"
        {% endif %}
        {% if entrypoint is defined -%}
        ENTRYPOINT ["{{ entrypoint | join('","') }}"]
        {% endif %}
        EOF

    - block:
      - name: "{{ title }} build builder"
        shell: >-
          podman build {{ dest_dir }} --volume {{ portage_dir }}:/var/db/repos/gentoo --volume {{  builder.base }}/data/packages:/packages --volume {{ builder.base }}/data/distfiles:/distfiles -t {{ builder_image }} --target builder {% if image_info.name == "scratch" %}--squash-all{%endif%}  > >(tee -a {{ dest_dir }}/podman-build.log) 2> >(tee -a {{ dest_dir  }}/podman-build.log >&2)

      - block: 
        - name: "{{ title }} build image"
          shell: >-
            podman build {{ dest_dir }} --volume {{ portage_dir }}:/var/db/repos/gentoo --volume {{ builder.base }}/data/packages:/packages --volume {{ builder.base }}/data/distfiles:/distfiles -t {{ build_image }} > >(tee -a {{ dest_dir }}/podman-build.log) 2> >(tee -a {{ dest_dir  }}/podman-build.log >&2)

        - name: "{{ title }} test image"
          shell: |
            podman run -t --rm {{ build_image }} {{ image_info.test }} 2>&1 | cat > {{ dest_dir  }}/test.log
          when: image_info.test is defined

        - name: "{{ title }} push to registry"
          shell: |
            podman push {{ build_image }}
            {% if image_info.name == "base" %}
            podman tag {{ build_image }} {{ latest_image }}
            podman push {{ latest_image }}
            {% endif %}
        when: "image_info.name != 'scratch'"
      #when: "image_info.name != 'scratch' or check_core.rc != 0 or check_stage3.rc != 0 or not check_portage.stat.exists or check_scratch.rc != 0 or check_builder.rc != 0"
      when: "image_info.name != 'scratch' and (check_image.status != 200 or check_builder.rc != 0)"
    when: image_info.type == 'gentoo-image-builder'
  
  - block:
    - name: "{{ title }} fetch image from registry and push to local registry"
      shell: |
        set -x
        echo "{{ platform | default(default_platform) }} {{ image_info.source }}:{{ image_info.tag | default('latest') }} {{ image_info.section }}" | pull-tag-push.sh
      register: image2local
    - debug: var=image2local
      failed_when: false
    when: image_info.type == 'fetch'
  
  - block:
    - name: "{{ title }} - run helper to process templates directory"
      include_role:
        name: shared_helper
        tasks_from: template_directory.yaml
      vars:
        dir_var: build_dir
    - name: "{{ title }} build image"
      shell: |
        set -xe
        image="{{ registry }}/{{ image_info.section }}/{{ image_info.name }}:{{ image_info.tag | default('latest') }}"
        {{ image_info.command }}
      args:
        chdir: "{{ build_dir.path }}"
      register: build_out
    
    - debug: var=build_out
      failed_when: false
    when: image_info.type == 'script'
  when: "'status' not in check_image.keys() or (image_info.name != 'scratch' and check_image is defined and 'status' in check_image.keys() and check_image.status != 200) or image_info.type == 'gentoo-image-builder'"
  
- name: "{{ title }} record image as processed"
  set_fact:
    images_processed: "{{ images_processed + [image_info.name] }}"  
